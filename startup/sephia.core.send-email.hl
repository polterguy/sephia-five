
/*
 * Creates our "send email" event.
 *
 * Requires [subject], [body], [to] and optionally [cc] and [bcc], which all should be a comma separated list of emails.
 * Optionally pass in [attachments] as collections of attachments to send with email.
 *
 * [to], [cc] and [bcc] should be comma separated list of emails.
 *
 * You can also pass in [markdown] and set its value to "true", at which point the email will also create an alternate
 * HTML view, created by converting its text content to markdown.
 *
 * In addition, you can create any number of additional MIME headers for your email, by putting them as key/value
 * items inside of a [headers] collection.
 */
create-event:sephia.core.send-email

  /*
   * Sanity check, we'll need [subject], [body] and at least one [to] recipient,
   * otherwise we'll throw an exception.
   * First checking if [subject] exists.
   */
  if:x:/../*/subject?value
    not
    or:x:/../*/subject?value
      =:
    throw:No subject for email!

  /*
   * Then checking if [body] exists.
   */
  if:x:/../*/body?value
    not
    or:x:/../*/body?value
      =:
    throw:No body for email!

  /*
   * Then checking if [to] exists.
   */
  if:x:/../*/to?value
    not
    or:x:/../*/to?value
      =:
    throw:No recipients for email!

  /*
   * Retrieving settings for currently logged in user.
   */
  whoami
  p5.auth.my-settings.get

  /*
   * Parametrizing SMTP invocation.
   * First "To" field.
   */
  split:x:/../*/to?value
    =:,
    =:" "
  add:x:/../*/p5.smtp.send/*/*/To
    src:x:/@split/*?name

  /*
   * Then "Cc" field.
   */
  split:x:/../*/cc?value
    =:,
    =:" "
  add:x:/../*/p5.smtp.send/*/*/Cc
    src:x:/@split/*?name

  /*
   * Then "Bcc" field.
   */
  split:x:/../*/bcc?value
    =:,
    =:" "
  add:x:/../*/p5.smtp.send/*/*/Bcc
    src:x:/@split/*?name

  /*
   * Looping through each "To", "Cc" and "Bcc" field in SMTP invocation,
   * and making sure we add the name from database as recipient, in addition to
   * moving the email address into the value of node.
   */
  p5.mysql.connect:[sephia]
    for-each:x:/../*/p5.smtp.send/*/*(/To|/Cc|/Bcc)/*
      p5.mysql.select:@"select name from contacts where username = @username and email = @email limit 1"
        @username:x:/@whoami/*/username?value
        @email:x:/@_dp/#?name
      set:x:/@_dp/#?value
        src:x:/@_dp/#?name
      set:x:/@_dp/#?name
        src:x:/@p5.mysql.select/*/*/name?value

  /*
   * Then "Sender".
   */
  add:x:/../*/p5.smtp.send/*/*/Sender
    src:@"{0}:{1}"
      :x:/@p5.auth.my-settings.get/*/sephia/*/name?value
      :x:/@p5.auth.my-settings.get/*/sephia/*/email?value

  /*
   * Then attachments.
   */
  for-each:x:/../*/attachments/*

    /*
     * Copy file into attachment folder, and figuring out new path 
     * for file from attachments folder.
     *
     * This is done to make sure we have all email attachments in
     * the same folder, which implies that we'll need to create a unique
     * filename, which is why we're using the [prefix], which is simply
     * a random GUID. Without this random GUID, we could run the risk
     * of having multiple attachments with the same filename overwrite
     * each other.
     *
     * Hence, an attachment file has three parts in our database.
     *
     * - [folder] being the folder, which is normally @SEPHIA-USER-ATTACHMENTS.
     * - [prefix] being a random GUID.
     * - [filename] being the filename of the attachment.
     *
     * Hence, to actually retrieve the physical file on disc, you'll need
     * to know both its folder, prefix and filename.
     */
    p5.types.guid.new
    split:x:/@_dp/#?value
      =:/
    copy-file:x:/@_dp/#?value
      dest:@SEPHIA-USER-ATTACHMENTS/{0}-{1}
        :x:/@p5.types.guid.new?value
        :x:/@split/0/-?name

    /*
     * Figuring out MIME type for file.
     */
    eval-x:x:/+/*
    sephia.core._get-mime-type
      folder:@SEPHIA-USER-ATTACHMENTS/
      filename:x:/@split/0/-?name
      prefix:x:/@p5.types.guid.new?value

    /*
     * Checking if file was supported, and if so, we add it up 
     * to [sephia.core.send-email._save-envelope] invocation below, and
     * the [p5.smtp.send] invocation.
     */
    if:x:/@sephia.core._get-mime-type/*

      /*
       * First adding file to [p5.smtp.send].
       */
      add:x:/../*/p5.smtp.send/*/*/*/multipart
        src:x:/@sephia.core._get-mime-type/*

      /*
       * Then adding file to [sephia.core.send-email._save-envelope].
       */
      eval-x:x:/+/*/*/*
      add:x:/../*/sephia.core.send-email._save-envelope
        src
          file
            folder:@SEPHIA-USER-ATTACHMENTS/
            filename:x:/@split/0/-?name
            prefix:x:/@p5.types.guid.new?value

    else

      /*
       * File extension was not supported, throwing an exception to notify caller,
       * after first deleting file from disc.
       */
      delete-file:@SEPHIA-USER-ATTACHMENTS/{0}-{1}
        :x:/@p5.types.guid.new?value
        :x:/@split/0/-?name
      split:x:/@split/0/-?name
        =:/
      split:x:/@split/@split/0/-?name
        =:.

      /*
       * Trying to give user a sane and readable error message.
       */
      throw:@"File ""{0}"" is not supported by Sephia Five. Modify your ""/config/legal-mime-types.hl"" configuration file,
and add support for "".{1}"" file extensions if you wish to allow these types of files."
        :x:/@split/@split/0/-?name
        :x:/@split/0/-?name

  /*
   * Cleaning up arguments and removing unused To, Cc, Bcc fields.
   */
  set:x:/../*/p5.smtp.send/*/*(/Cc|/Bcc)(!/*/.)

  /*
   * Adding cryptography keys for all recipients,
   * if we can find public PGP keys for all recipients.
   */
  p5.crypto.list-public-keys:x:/../*/p5.smtp.send/*/*(/To|/Cc|/Bcc)/*?value
  if:x:/@p5.crypto.list-public-keys/*?count
    =:x:/../*/p5.smtp.send/*/*(/To|/Cc|/Bcc)/*?count

    /*
     * We've got cryptography keys for all recipients.
     */
    add:x:/../*/p5.smtp.send/*/*/*/multipart
      src:encrypt
    for-each:x:/../*/p5.smtp.send/*/*(/To|/Cc|/Bcc)/*
      eval-x:x:/+/*/*
      add:x:/../*/p5.smtp.send/*/*/*/multipart/*/encrypt
        src
          email:x:/@_dp/#?value

  /*
   * Then checking if email should be signed.
   *
   * Notice, if email is to be signed, we automatically attach the public PGP key
   * for the user as an attachment.
   */
  if:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
    and:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
      !=:

    /*
     * Email should (possibly) be signed.
     * Before we know for sure, we must check up if the private PGP key exists in GnuPG database.
     */
    p5.crypto.list-private-keys:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
    if:x:/-/*

      /*
       * Private key exists in GnuPG database.
       */
      eval-x:x:/+/*/*/**
      add:x:/../*/p5.smtp.send/*/envelope/*/body/*/multipart
        src
          sign
            fingerprint:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
              password:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-password?value

      /*
       * Automatically attaching public PGP key as an attachment to email.
       *
       * Notice, we simply include it as an inline attachment, and we don't bother
       * to store the fact that we attached it into our database.
       */
      p5.crypto.get-public-key:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
      eval-x:x:/+/*/*/*/content
      add:x:/../*/p5.smtp.send/*/envelope/*/body/*/multipart
        src
          application:pgp-key
            Content-Disposition:attachment; filename=public-key.pgp
            Content-Transfer-Encoding:7bit
            content:x:/@p5.crypto.get-public-key/*?value

  /*
   * Checking if caller specified he wanted to have Markdown created.
   */
  if:x:/../*/markdown?value
    =:bool:true

    /*
     * Creating Markdown out of email content to use as HTML view.
     */
    sephia.core._markdown-body-2-html:x:/../*/body?value

    /*
     * Adding an alternate view of type HTML, using the email's text content
     * converted from Markdown as its content.
     */
    eval-x:x:/+/*/*/*/*
    add:x:/../*/p5.smtp.send/**/multipart
      src
        multipart:alternative
          text:plain
            content:x:/../*/body?value
          text:html
            content:x:/@sephia.core._markdown-body-2-html?value

  else

    /*
     * No alternative view is to be created.
     */
    eval-x:x:/+/*/*/*
    add:x:/../*/p5.smtp.send/**/multipart
      src
        text:plain
          content:x:/../*/body?value

  /*
   * Adding any additional MIME headers specified by caller.
   */
  add:x:/../*/p5.smtp.send/*/envelope
    src:x:/../*/headers/*

  /*
   * Forward evaluating entire SMTP invocation.
   */
  eval-x:x:/../*/p5.smtp.send/**

  /*
   * Storing entire outgoing [envelope] to [_save-envelope].
   */
  add:x:/../*/sephia.core.send-email._save-envelope
    src:x:/../*/p5.smtp.send/*/envelope

  /*
   * Sending email.
   */
  p5.smtp.send
    server:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-server?value
    port:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-port?value
    ssl:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-ssl?value
    username:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-username?value
    password:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-password?value
    envelope
      Subject:x:/../*/subject?value
      Sender
      To
      Cc
      Bcc
      body
        multipart:mixed

  /*
   * Making sure we update MessageId accordingly.
   */
  set:x:/../*/sephia.core.send-email._save-envelope/*/envelope?value
    src:x:/@p5.smtp.send/*/envelope?value

  /*
   * Saves entire outgoing [envelope] to database.
   */
  sephia.core.send-email._save-envelope





/*
 * Saves outgoing [envelope] to database.
 *
 * Expects [envelope] as argument, being entire SMTP envelope.
 *
 * Also expects (outside of envelope) one [file] object for each attachment, having [filename], [prefix] and [folders]
 * as arguments.
 */
create-event:sephia.core.send-email._save-envelope

  /*
   * Open database connection.
   */
  p5.mysql.connect:[sephia]

    /*
     * Using database transaction, to avoid having incomplete database objects,
     * in case an exception occurs.
     */
    p5.mysql.transaction.begin

      /*
       * Needed later.
       */
      whoami

      /*
       * First adding any non existing contacts.
       */
      for-each:x:/../*/envelope/*(/To|/Cc|/Bcc)/*

        /*
         * Checking if contact exists from before.
         */
        p5.mysql.select:@"select count(*) from contacts where username = @username and email = @email"
          @username:x:/@whoami/*/username?value
          @email:x:/@_dp/#?value
        if:x:/@p5.mysql.select/*?count.int
          =:int:0

          /*
           * Inserting new contact, defaulting name to "Unknown".
           */
          p5.mysql.insert:@"insert into contacts (name, email, username) values ('Unknown', @email, @username)"
            @email:x:/@_dp/#?value
            @username:x:/@whoami/*/username?value

      /*
       * Checking if "sender" (self) exists in contact database.
       */
      _sender
      p5.mysql.select:@"select * from contacts where username = @username and email = @email"
        @username:x:/@whoami/*/username?value
        @email:x:/../*/envelope/*/Sender/*?value
      if:x:/@p5.mysql.select/*?count.int
        =:int:0

        /*
         * Inserting "self" (sender) into "contacts" table in database.
         */
        p5.auth.my-settings.get
        p5.mysql.insert:@"insert into contacts (name, email, username) values (@name, @email, @username)"
          @name:x:/@p5.auth.my-settings.get/*/sephia/*/name?value
          @email:x:/@p5.auth.my-settings.get/*/sephia/*/email?value
          @username:x:/@whoami/*/username?value
        set:x:/@_sender?value
          src:x:/@p5.mysql.insert/*/id?value

      else

        /*
         * Self already exists in contacts table in database.
         */
        set:x:/@_sender?value
          src:x:/@p5.mysql.select/0/*/id?value

      /*
       * Checking if email is encrypted.
       */
      _encrypt:int:0
      if:x:/../*/envelope/*/body/*/multipart/*/encrypt
        set:x:/@_encrypt?value
          src:int:1

      /*
       * Checking if email is signed.
       */
      _signature
      _fingerprint
      if:x:/../*/envelope/*/body/*/multipart/*/sign

        /*
         * Retrieving PGP key's fingerprint, and doing lookup into 
         * GnuPG database to find its User ID, making sure we store both signature and fingerprint
         * of key as we insert our email into database.
         * Notice, we do a [to-upper] conversion of fingerprint, to make sure we store all
         * fingerprints the same way.
         */
        set:x:/@_fingerprint?value
          to-upper:x:/../*/envelope/*/body/*/multipart/*/sign/*/fingerprint?value
        p5.crypto.get-key-details:x:/../*/envelope/*/body/*/multipart/*/sign/*/fingerprint?value
        set:x:/@_signature?value
          src:x:/@p5.crypto.get-key-details/*/*/user-ids/0?value

      /*
       * Inserting into "email" table in database.
       */
      p5.types.date.now
        local:true
      p5.mysql.insert:@"insert into emails (subject, date, sender, username, isread, mimeid, signature, fingerprint, encrypted, type, inreplyto) values (@subject, @date, @sender, @username, 1, @mimeid, @signature, @fingerprint, @encrypted, 'sent', @inreplyto)"
        @subject:x:/../*/envelope/*/Subject?value
        @date:x:/@p5.types.date.now?value
        @sender:x:/@_sender?value
        @username:x:/@whoami/*/username?value
        @mimeid:x:/../*/envelope?value
        @encrypted:x:/@_encrypt?value
        @signature:x:/@_signature?value
        @fingerprint:x:/@_fingerprint?value
        @inreplyto:x:/../*/envelope/*/In-Reply-To?value

      /*
       * Inserting into "parts" table in database.
       */
      p5.mysql.insert:@"insert into parts (type, content, emailid) values ('plain', @content, @emailid)"
        @content:x:/../*/envelope/*/body/**/text/=plain/*/content?value
        @emailid:x:/@p5.mysql.insert/@p5.mysql.insert/*/id?value

      /*
       * Checking if HTML view was given.
       */
      if:x:/../*/envelope/*/body/**/text/=html/*/content?value

        /*
         * Inserting also alternative HTML view.
         */
        p5.mysql.insert:@"insert into parts (type, content, emailid) values ('html', @content, @emailid)"
          @content:x:/../*/envelope/*/body/**/text/=html/*/content?value
          @emailid:x:/@p5.mysql.insert/@p5.mysql.insert/@p5.mysql.insert/*/id?value

      /*
       * Inserting into "recipients" table in database.
       */
      for-each:x:/../*/envelope/*(/To|/Cc|/Bcc)/*
        p5.mysql.select:@"select id from contacts where username = @username and email = @email"
          @username:x:/@whoami/*/username?value
          @email:x:/../*/envelope/*/Sender/*?value
        p5.mysql.insert:@"insert into recipients (contactid, type, emailid) values (@contactid, @type, @emailid)"
          @contactid:x:/@p5.mysql.select/*/*/id?value
          @type:x:/@_dp/#/.?name
          @emailid:x:/..for-each/@p5.mysql.insert/@p5.mysql.insert/*/id?value

      /*
       * Inserting into "attachments" table in database.
       */
      for-each:x:/../*/file
        p5.io.unroll-path:x:/@_dp/#/*/folder?value
        p5.mysql.insert:@"insert into attachments (filename, prefix, folder, emailid) values (@filename, @prefix, @folder, @emailid)"
          @filename:x:/@_dp/#/*/filename?value
          @prefix:x:/@_dp/#/*/prefix?value
          @folder:x:/@p5.io.unroll-path?value
          @emailid:x:/@p5.mysql.insert/@p5.mysql.insert/@p5.mysql.insert/*/id?value

      /*
       * Committing transaction.
       */
      p5.mysql.transaction.commit
