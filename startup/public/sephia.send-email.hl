
/*
 * Creates our "send email" event.
 *
 * Requires [subject], [body], [to] and optionally [cc] and [bcc], which all should be a comma separated list of emails.
 * Optionally pass in [attachments] as collections of attachments to send with email.
 * Attachments should be, if given, a collection of nodes, having values pointing to files on the server.
 *
 * [to], [cc] and [bcc] should be comma separated list of emails.
 */
create-event:sephia.send-email

  /*
   * Sanity check, verifies that at least [subject], [body] and [to] is given.
   */
  micro.lambda.contract.min:x:/..
    subject:string
    body:string
    to:string

  /*
   * Retrieving settings for currently logged in user.
   */
  whoami
  p5.auth.my-settings.get

  /*
   * Used to hold envelope data for email.
   */
  .envelope
    To
    Cc
    Bcc
    Sender
    Subject
    body

  /*
   * Used to temporary hold fingerprints of all recipients of email.
   */
  .fingerprints

  /*
   * Adding all recipients' email addresses
   */
  add:x:/@.envelope/*/To
    split:x:/../*/to?value
      =:,
      =:" "
  add:x:/@.envelope/*/Cc
    split:x:/../*/cc?value
      =:,
      =:" "
  add:x:/@.envelope/*/Bcc
    split:x:/../*/bcc?value
      =:,
      =:" "

  /*
   * Removing any of [To], [Cc] and [Bcc] which does not contain children nodes.
   */
  set:x:/@.envelope/*(/Cc|/Bcc)(!/*/.)

  /*
   * Doing a lookup for each contact's name, and setting the correct node name above accordingly.
   * TODO: Optimize with a single SQL command.
   */
  p5.mysql.connect:[sephia]
    for-each:x:/@.envelope/*(/To|/Cc|/Bcc)/*
      p5.mysql.select:@"select name, fingerprint from contacts where username = @username and email = @email"
        @username:x:/@whoami/*/username?value
        @email:x:/@_dp/#?name

      /*
       * Notice, we first switch the name of the node to become its value,
       * before we set the name of the node to the contact's name from our database.
       */
      set:x:/@_dp/#?value
        src:x:/@_dp/#?name
      set:x:/@_dp/#?name
        src:x:/@p5.mysql.select/*/*/name?value

      /*
       * Storing fingerprint of contact for later reference, if contact has a fingerprint.
       */
      if:x:/@p5.mysql.select/*/*/fingerprint?value
        add:x:/@.fingerprints
          src:x:/@p5.mysql.select/*/*/fingerprint?value

  /*
   * Setting "Sender" of email.
   */
  add:x:/@.envelope/*/Sender
    src:@"{0}:{1}"
      :x:/@p5.auth.my-settings.get/*/sephia/*/name?value
      :x:/@p5.auth.my-settings.get/*/sephia/*/email?value

  /*
   * Adding subject to envelope.
   */
  set:x:/@.envelope/*/Subject?value
    src:x:/../*/subject?value

  /*
   * Used to track of envelope has been given a multipart or not.
   *
   * We try to keep construction of email as small as possible, and only
   * create a multipart if we really have to.
   */
  .has-multipart:bool:true

  /*
   * Then attachments.
   */
  for-each:x:/../*/attachments/*

    /*
     * Checking if attachment's file extension is a legal type of attachment.
     */
    if
      sephia._internals.is-legal-attachment:x:/@_dp/#?value

      /*
       * Checking if we need to create a multipart for envelope.
       */
      if:x:/@.has-multipart?value
        set:x:/@.has-multipart?value
          src:bool:false
        add:x:/@.envelope/*/body
          src
            multipart:mixed

      /*
       * Copy file into attachment folder, and figuring out new path 
       * for file from attachments folder.
       *
       * This is done to make sure we have all email attachments in
       * the same folder, which implies that we'll need to create a unique
       * filename, which is why we're using the [prefix], which is simply
       * a random GUID. Without this random GUID, we could run the risk
       * of having multiple attachments with the same filename overwrite
       * each other.
       *
       * Hence, an attachment file has three parts in our database.
       *
       * - [folder] being the folder, which is normally @SEPHIA-USER-ATTACHMENTS.
       * - [prefix] being a random GUID.
       * - [filename] being the filename of the attachment.
       */
      p5.io.unroll-path:@SEPHIA-USER-ATTACHMENTS/
      p5.types.guid.new
      split:x:/@_dp/#?value
        =:/
      copy-file:x:/@_dp/#?value
        dest:{0}{1}-{2}
          :x:/@p5.io.unroll-path?value
          :x:/@p5.types.guid.new?value
          :x:/@split/0/-?name

      /*
       * Figuring out MIME type for file.
       */
      eval-x:x:/+/*
      sephia._internals.mime.get-type-from-file-extension
        folder:x:/@p5.io.unroll-path?value
        filename:x:/@split/0/-?name
        prefix:x:/@p5.types.guid.new?value

      /*
       * Adding file to [.envelope].
       */
      add:x:/@.envelope/*/body/*/multipart
        src:x:/@sephia._internals.mime.get-type-from-file-extension/*

    else

      /*
       * Attachment was not a legal type of attachment in Sephia.
       *
       * Trying to give user a sane and readable error message.
       */
      throw:@"File ""{0}"" is not supported by Sephia Five"
        :x:/@split/@split/0/-?name

  /*
   * Checking if we should create an HTML view, by converting content of email into Markdown.
   */
  if:x:/@p5.auth.my-settings.get/*/sephia/*/markdown-composer?value

    /*
     * Caller requested that Markdown should be used.
     */
    sephia._internals.markdown.to-html:x:/../*/body?value
    eval-x:x:/+/*/*/*/*/content
    add:x:(/@.envelope/*/body/*/multipart|/@.envelope/*/body)/[0,1]
      src
        multipart:alternative
          text:plain
            content:x:/../*/body?value
          text:html
            content:x:/@sephia._internals.markdown.to-html?value

  else

    /*
     * Caller did not want to create an HTML view.
     */
    eval-x:x:/+/*/*/*/content
    add:x:(/@.envelope/*/body/*/multipart|/@.envelope/*/body)/[0,1]
      src
        text:plain
          content:x:/../*/body?value

  /*
   * Adding cryptography keys for all recipients,
   * if we found public PGP keys for all recipients.
   */
  p5.crypto.list-public-keys:x:/@.fingerprints/*?name
  if:x:/-/*?count
    =:x:/@.envelope/*(/To|/Cc|/Bcc)/*?count

    /*
     * We've got cryptography keys for all recipients.
     *
     * First adding an [encrypt] node to our multipart.
     */
    add:x:/@.envelope/*/body/0
      src:encrypt

    /*
     * Then adding up our [fingerprint] to [encrypt] node we created above.
     */
    for-each:x:/@.fingerprints/*?name
      eval-x:x:/+/*/*
      add:x:/@.envelope/*/body/0/*/encrypt
        src
          fingerprint:x:/@_dp?value

  /*
   * Then checking if email should be signed.
   */
  if:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
    and:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
      !=:

    /*
     * Email should (possibly) be signed.
     *
     * Before we know for sure, we must check up if the private PGP key exists in GnuPG database.
     */
    p5.crypto.list-private-keys:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
    if:x:/-/*

      /*
       * Private key exists in GnuPG database.
       */
      eval-x:x:/+/*/*/**
      add:x:/@.envelope/*/body/0
        src
          sign
            fingerprint:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
              password:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-password?value

  /*
   * Now we have created our message, and we can send it and save it to our database.
   *
   * Notice though, that when we send our message, we actually remove its subject, and 
   * add it as a MIME header named "X-Subject" inside of our innermost multipart, if
   * the email is supposed to be sent encrypted.
   *
   * This is done to hide the actual subject of our email, and have its real subject be encrypted,
   * while using a randomly generated subject outside of our encrypted parts.
   *
   * First we add entire [.envelope] into SMTP invocation.
   */
  add:x:/../*/p5.smtp.send/*/envelope
    src:x:/@.envelope/*

  /*
   * Babeling our subject, but only if email is to be sent encrypted.
   *
   * Notice, this is done on the data that now exists inside of [p5.smtp.send],
   * and will change the subject line, and move it into our encrypted parts of email,
   * if email is to be sent encrypted.
   */
  if:x:/../*/p5.smtp.send/*/envelope/*/body/0/*/encrypt

    /*
     * Email is be sent encrypted, "babeling" our subject.
     *
     * First base64 encoding actual subject, and adding to encrypted multipart entity.
     */
    p5.string.encode-base64:x:/../*/subject?value
    eval-x:x:/+/*/*
    insert-before:x:/../*/p5.smtp.send/*/envelope/*/body/0/0
      src
        X-Subject:x:/@p5.string.encode-base64?value

    /*
     * Then getting a new random subject, and exchanging actual subject with "babel subject".
     */
    sephia._internals.smtp.get-babel-subject
    set:x:/../*/p5.smtp.send/*/envelope/*/Subject?value
      src:x:/@sephia._internals.smtp.get-babel-subject?value

    /*
     * Then to support email clients that does not support our custom "X-Subject" MIME header,
     * we move subject line into both of its text parts.
     *
     * First we move subject into our "text:plain" MIME part's content.
     */
    set:x:/../*/p5.smtp.send/*/envelope/**/text/=plain/*/content?value
      src:@"### {0}

{1}"
        :x:/../*/subject?value
        :x:/../*/p5.smtp.send/*/envelope/**/text/=plain/*/content?value

    /*
     * Then we move our subject into our "text:html" MIME part's content, if there is one.
     */
    if:x:/../*/p5.smtp.send/*/envelope/**/text/=html

      /*
       * There is an HTML part, hence we'll need to inject an "h3" element into the top 
       * of our "body" element.
       */
      html2lambda:x:/../*/p5.smtp.send/*/envelope/**/text/=html/*/content?value
      eval-x:x:/+/*/*/*
      insert-before:x:/@html2lambda/**/body/0
        src
          h3
            #text:x:/../*/subject?value
      lambda2html:x:/@html2lambda/*
      set:x:/../*/p5.smtp.send/*/envelope/**/text/=html/*/content?value
        src:x:/@lambda2html?value

  /*
   * Final preparings to send and save our email.
   */
  eval-x:x:/../*/p5.smtp.send/*
  add:x:/../*/sephia._internals.smtp.save-envelope/*
    src:x:/@.envelope/*

  /*
   * Sending our actual email using our user's SMTP settings.
   */
  p5.smtp.send
    server:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-server?value
    port:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-port?value
    ssl:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-ssl?value
    username:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-username?value
    password:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-password?value
    envelope

  /*
   * Saves entire outgoing [envelope] to database.
   *
   * Notice, contrary to what goes to our SMTP server, this [envelope] is saved as it
   * actually is, without our "babel subject".
   *
   * But we'll need to make sure the email is saved with the correct MIME ID, which is returned
   * from above invocation to [p5.smtp.send].
   */
  set:x:/+/*?value
    src:x:/@p5.smtp.send/*/envelope?value
  sephia._internals.smtp.save-envelope
    envelope
