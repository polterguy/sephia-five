
/*
 * Creates our "send email" event.
 *
 * Requires [subject], [body], [to] and optionally [cc] and [bcc], which all should be a comma separated list of emails.
 * Optionally pass in [attachments] as collections of attachments to send with email.
 *
 * [to], [cc] and [bcc] should be comma separated list of emails.
 *
 * You can also pass in [markdown] and set its value to "true", at which point the email will also create an alternate
 * HTML view, created by converting its text content to markdown.
 *
 * In addition, you can create any number of additional MIME headers for your email, by putting them as key/value
 * items inside of a [headers] collection.
 */
create-event:sephia.smtp.send-email

  /*
   * Sanity check.
   * Verifies that the given arguments are passed into invocation of event.
   */
  micro.contract:x:/..
    subject:string
    body:string
    to:string

  /*
   * Retrieving settings for currently logged in user.
   */
  whoami
  p5.auth.my-settings.get

  /*
   * Parametrizing SMTP invocation.
   * First "To" field.
   */
  split:x:/../*/to?value
    =:,
    =:" "
  add:x:/../*/p5.smtp.send/*/*/To
    src:x:/@split/*?name

  /*
   * Then "Cc" field.
   */
  split:x:/../*/cc?value
    =:,
    =:" "
  add:x:/../*/p5.smtp.send/*/*/Cc
    src:x:/@split/*?name

  /*
   * Then "Bcc" field.
   */
  split:x:/../*/bcc?value
    =:,
    =:" "
  add:x:/../*/p5.smtp.send/*/*/Bcc
    src:x:/@split/*?name

  /*
   * Looping through each "To", "Cc" and "Bcc" field in SMTP invocation,
   * and making sure we add the name from database as recipient, in addition to
   * moving the email address into the value of node.
   *
   * In addition, we store all fingerprints in our [_crypto-keys] below, 
   * such that we can use it as the basis for encrypting the email later.
   */
  _crypto-keys
  p5.mysql.connect:[sephia]
    for-each:x:/../*/p5.smtp.send/*/*(/To|/Cc|/Bcc)/*
      p5.mysql.select:@"select name, fingerprint from contacts where username = @username and email = @email limit 1"
        @username:x:/@whoami/*/username?value
        @email:x:/@_dp/#?name
      set:x:/@_dp/#?value
        src:x:/@_dp/#?name
      set:x:/@_dp/#?name
        src:x:/@p5.mysql.select/*/*/name?value
      if:x:/@p5.mysql.select/*/*/fingerprint?value
        add:x:/@_crypto-keys
          src:x:/@p5.mysql.select/*/*/fingerprint?value

  /*
   * Then "Sender".
   */
  add:x:/../*/p5.smtp.send/*/*/Sender
    src:@"{0}:{1}"
      :x:/@p5.auth.my-settings.get/*/sephia/*/name?value
      :x:/@p5.auth.my-settings.get/*/sephia/*/email?value

  /*
   * Then attachments.
   */
  for-each:x:/../*/attachments/*

    /*
     * Copy file into attachment folder, and figuring out new path 
     * for file from attachments folder.
     *
     * This is done to make sure we have all email attachments in
     * the same folder, which implies that we'll need to create a unique
     * filename, which is why we're using the [prefix], which is simply
     * a random GUID. Without this random GUID, we could run the risk
     * of having multiple attachments with the same filename overwrite
     * each other.
     *
     * Hence, an attachment file has three parts in our database.
     *
     * - [folder] being the folder, which is normally @SEPHIA-USER-ATTACHMENTS.
     * - [prefix] being a random GUID.
     * - [filename] being the filename of the attachment.
     *
     * Hence, to actually retrieve the physical file on disc, you'll need
     * to know both its folder, prefix and filename.
     */
    p5.types.guid.new
    split:x:/@_dp/#?value
      =:/
    copy-file:x:/@_dp/#?value
      dest:@SEPHIA-USER-ATTACHMENTS/{0}-{1}
        :x:/@p5.types.guid.new?value
        :x:/@split/0/-?name

    /*
     * Figuring out MIME type for file.
     */
    eval-x:x:/+/*
    sephia._internals.mime.get-type-from-file-extension
      folder:@SEPHIA-USER-ATTACHMENTS/
      filename:x:/@split/0/-?name
      prefix:x:/@p5.types.guid.new?value

    /*
     * Checking if file was supported, and if so, we add it up 
     * to [sephia._internals.smtp.save-envelope] invocation below, and
     * the [p5.smtp.send] invocation.
     */
    if:x:/@sephia._internals.mime.get-type-from-file-extension/*

      /*
       * First adding file to [p5.smtp.send].
       */
      add:x:/../*/p5.smtp.send/*/*/*/multipart
        src:x:/@sephia._internals.mime.get-type-from-file-extension/*

      /*
       * Then adding file to [sephia._internals.smtp.save-envelope].
       */
      eval-x:x:/+/*/*/*
      add:x:/../*/sephia._internals.smtp.save-envelope
        src
          file
            folder:@SEPHIA-USER-ATTACHMENTS/
            filename:x:/@split/0/-?name
            prefix:x:/@p5.types.guid.new?value

    else

      /*
       * File extension was not supported, throwing an exception to notify caller,
       * after first deleting file from disc.
       */
      delete-file:@SEPHIA-USER-ATTACHMENTS/{0}-{1}
        :x:/@p5.types.guid.new?value
        :x:/@split/0/-?name
      split:x:/@split/0/-?name
        =:/
      split:x:/@split/@split/0/-?name
        =:.

      /*
       * Trying to give user a sane and readable error message.
       */
      throw:@"File ""{0}"" is not supported by Sephia Five. Modify your ""/config/legal-mime-types.hl"" configuration file,
and add support for "".{1}"" file extensions if you wish to allow these types of files."
        :x:/@split/@split/0/-?name
        :x:/@split/0/-?name

  /*
   * Cleaning up arguments and removing unused To, Cc, Bcc fields.
   */
  set:x:/../*/p5.smtp.send/*/*(/Cc|/Bcc)(!/*/.)

  /*
   * Adding cryptography keys for all recipients,
   * if we found public PGP keys for all recipients.
   */
  p5.crypto.list-public-keys:x:/@_crypto-keys/*?name
  if:x:/@p5.crypto.list-public-keys/*?count
    =:x:/../*/p5.smtp.send/*/*(/To|/Cc|/Bcc)/*?count

    /*
     * We've got cryptography keys for all recipients.
     */
    add:x:/../*/p5.smtp.send/*/*/*/multipart
      src:encrypt
    for-each:x:/@_crypto-keys/*?name
      eval-x:x:/+/*/*
      add:x:/../*/p5.smtp.send/*/*/*/multipart/*/encrypt
        src
          fingerprint:x:/@_dp?value

  /*
   * Then checking if email should be signed.
   */
  if:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
    and:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
      !=:

    /*
     * Email should (possibly) be signed.
     * Before we know for sure, we must check up if the private PGP key exists in GnuPG database.
     */
    p5.crypto.list-private-keys:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
    if:x:/-/*

      /*
       * Private key exists in GnuPG database.
       */
      eval-x:x:/+/*/*/**
      add:x:/../*/p5.smtp.send/*/envelope/*/body/*/multipart
        src
          sign
            fingerprint:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-key?value
              password:x:/@p5.auth.my-settings.get/*/sephia/*/pgp-password?value

  /*
   * Checking if email is supposed to be encrypted, at which point
   * we move the subject into the main multipart, and generate a random subject instead,
   * in addition to adding our own custom header where we keep the original subject.
   */
  _smtp-subject
  _smtp-body-plain
  _smtp-body-html
  _smtp-x-subject
  if:x:/../*/p5.smtp.send/*/envelope/*/body/*/multipart/*/encrypt

    /*
     * Email is to be sent encrypted, making sure we find some random subject, before
     * we move the real subject into the body of the email, and add our real subject into
     * the main multipart in a custom "X-Subject" header inside of the encrypted parts of email.
     */
    sephia._internals.smtp.get-babel-subject
    set:x:/@_smtp-body-plain?value
      src:@"### Subject - {0}

{1}"
        :x:/../*/subject?value
        :x:/../*/body?value

    /*
     * Adding real subject into main multipart as a custom MIME header, making sure
     * we base64 encode the subject first.
     */
    p5.string.encode-base64:x:/../*/subject?value
    set:x:/@_smtp-x-subject?value
      src:x:/@p5.string.encode-base64?value

    /*
     * Then making sure we use bogus subject from "subject generator".
     */
    set:x:/@_smtp-subject?value
      src:x:/@sephia._internals.smtp.get-babel-subject?value

  /*
   * Checking if caller specified he wanted to have Markdown created.
   */
  if:x:/../*/markdown?value
    =:bool:true

    /*
     * Creating Markdown out of email content to use as HTML view.
     */
    sephia._internals.markdown.to-html:x:/../*/body?value

    /*
     * Adding an alternate view of type HTML, using the email's text content
     * converted from Markdown as its content.
     */
    eval-x:x:/+/*/*/*/*
    add:x:/../*/p5.smtp.send/**/multipart
      src
        multipart:alternative
          text:plain
            content:x:/../*/body?value
          text:html
            content:x:/@sephia._internals.markdown.to-html?value

    /*
     * Checking if email was to be sent encrypted, at which point the [body]
     * we're supposed to send, can actually be found in [_smtp-body-plain] and [_smtp-body-html].
     */
    if:x:/../*/p5.smtp.send/*/envelope/*/body/*/multipart/*/encrypt
      sephia._internals.markdown.to-html:x:/@_smtp-body-plain?value
      set:x:/@_smtp-body-html?value
        src:x:/@sephia._internals.markdown.to-html?value

  else

    /*
     * No alternative view is to be created.
     */
    eval-x:x:/+/*/*/*
    add:x:/../*/p5.smtp.send/**/multipart
      src
        text:plain
          content:x:/../*/body?value

  /*
   * Adding any additional MIME headers specified by caller.
   */
  add:x:/../*/p5.smtp.send/*/envelope
    src:x:/../*/headers/*

  /*
   * Forward evaluating entire SMTP invocation.
   */
  eval-x:x:/../*/p5.smtp.send/**

  /*
   * Storing entire outgoing [envelope] to [_save-envelope].
   */
  add:x:/../*/sephia._internals.smtp.save-envelope
    src:x:/../*/p5.smtp.send/*/envelope

  /*
   * Making sure we use the "cryptography overrides" for our SMTP invocation if email is
   * to be sent encrypted.
   */
  if:x:/../*/p5.smtp.send/*/envelope/*/body/*/multipart/*/encrypt
    add:x:/../*/p5.smtp.send/*/envelope/*/body/*/multipart
      src:"X-Subject:{0}"
        :x:/@_smtp-x-subject?value
    set:x:/../*/p5.smtp.send/*/envelope/*/Subject?value
      src:x:/@_smtp-subject?value
    set:x:/../*/p5.smtp.send/*/envelope/*/body/*/multipart/**/text/=plain/*/content?value
      src:x:/@_smtp-body-plain?value
    set:x:/../*/p5.smtp.send/*/envelope/*/body/*/multipart/**/text/=html/*/content?value
      src:x:/@_smtp-body-html?value

  /*
   * Sending email.
   */
  p5.smtp.send
    server:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-server?value
    port:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-port?value
    ssl:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-ssl?value
    username:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-username?value
    password:x:/@p5.auth.my-settings.get/*/sephia/*/smtp-password?value
    envelope
      Subject:x:/../*/subject?value
      Sender
      To
      Cc
      Bcc
      body
        multipart:mixed

  /*
   * Making sure we update MessageId accordingly.
   */
  set:x:/../*/sephia._internals.smtp.save-envelope/*/envelope?value
    src:x:/@p5.smtp.send/*/envelope?value

  /*
   * Saves entire outgoing [envelope] to database.
   */
  sephia._internals.smtp.save-envelope
