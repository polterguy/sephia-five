﻿﻿
/*
 * Updates the given [id] contact with the given [name] and [email] arguments, 
 * and returns the ID, and all other properties of the contact.
 *
 * Optionally pass in [fingerprint], which is the fingerprint of the public PGP key
 * the contact should be associated with.
 *
 * If you pass in a [fingerprint] and [verified], and set [verified]'s value to 
 * boolean "true", the contact will be set as verified.
 *
 * You can also optionally pass in [spam], which can be either "0" or "1", where "0" 
 * means that all emails originating from contact in the future is to be considered
 * as not spam, and "1" implying that all future emails from the contact is to
 * be considered as "spam".
 *
 * If you don't pass in [spam], then the spam filters in Sephia will try to 
 * determine if future emails from the contact are to be considered spam or not.
 *
 * Will attempt to find a public PGP key for contact, either in GnuPG database, 
 * or using key server, but only if a [fingerprint] is supplied, and the contact
 * does not have a verified fingerprint from before.
 *
 * Notice, the event expects an open database connection to the Sephia database.
 */
create-event:sephia._internals.contacts.update

  /*
   * Making sure invoker obeys by lambda contract.
   */
  micro.lambda.contract.min:x:/..
    id:long
    name:string
    email:string

  /*
   * Sanity checking optional arguments.
   */
  micro.lambda.contract.optional:x:/..
    fingerprint:string
    verified:bool
    spam:int

  /*
   * Making sure name defaults to first parts of email, if it is empty or null.
   */
  if:x:/../*/name?value
    =:
    split:x:/../*/email?value
      =:@
    set:x:/../*/name?value
      src:x:/@split/0?name

  /*
   * Used to hold any fingerprints of public PGP key matching email.
   */
  _fingerprint

  /*
   * Checking if caller provided a [fingerprint] argument, and the contact does
   * not have an existing fingerprint association, that has already been verified.
   */
  if:x:/../*/fingerprint?value
    and
      fetch:x:/0?value.int
        p5.mysql.scalar:@"select count(*) from contacts where id = @id and (isverified = 0 or fingerprint is null)"
          @id:x:/../*/id?value
      =:int:1

    /*
     * Attempting to find the given [fingerprint] key for the given [email].
     *
     * Notice, our invocation below, will return null if no key was found.
     *
     * Otherwise, it will return the [fingerprint] of the key that was successfully found.
     */
    eval-x:x:/+/*/*
    set:x:/@_fingerprint?value
      sephia.pgp.get-key
        email:x:/../*/email?value
        fingerprint:x:/../*/fingerprint?value

  /*
   * We always store fingerprint as UPPER case in our database.
   */
  if:x:/@_fingerprint?value
    set:x:/@_fingerprint?value
      to-upper:x:/@_fingerprint?value

  /*
   * Checking if caller requested contact to be updated to a verified contact.
   */
  _is-verified:int:0
  if:x:/../*/verified?value
    and:x:/@_fingerprint?value

    /*
     * We have a fingerprint for contact, and caller requested that contact be updated
     * to become verified - Hence, we set status of contact to verified.
     */
    set:x:/@_is-verified?value
      src:1

  /*
   * Updating our contact.
   */
  p5.mysql.update:@"update contacts set name = @name, email = @email, fingerprint = @fingerprint, isverified = @isverified, spam = @spam where id = @id"
    @name:x:/../*/name?value
    @email:x:/../*/email?value
    @fingerprint:x:/@_fingerprint?value
    @isverified:x:/@_is-verified?value
    @spam:x:/../*/spam?value
    @id:x:/../*/id?value

  /*
   * Returning the updated data for our contact.
   */
  eval-x:x:/+/*
  return
    id:x:/../*/id?value
    name:x:/../*/name?value
    email:x:/../*/email?value
    fingerprint:x:/@_fingerprint?value
    isverified:x:/@_is-verified?value
    spam:x:/../*/spam?value
