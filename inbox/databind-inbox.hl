
/*
 * Databinds our inbox datagrid.
 *
 * Requires no arguments, but you can optionally pass in [offset] and [filter] when invoking file,
 * to start out on a specific page, with a specified filter condition.
 *
 * Filter can be "typed", by starting it out with a "type declaration" followed by a colon.
 * Legal types are 'inbox:', 'sent:' and 'unread:'
 */
.defaults
  offset:int:0
  filter:"inbox:"





/*
 * Sanity checking optional arguments.
 */
micro.lambda.contract.optional:x:/..
  offset:long
  filter:string





/*
 * Needed to parametrize SQL select queries.
 */
whoami





/*
 * Parsing filter, such that we only search types of emails specified by caller.
 */
if:x:/../*/filter?value
  not
  or:x:/../*/filter?value
    =:
  set:x:/../*/filter
_filter
if
  fetch:x:/0/0?value
    index-of:x:(/../*/filter|/../*/.defaults/*/filter)/$?value
      src:":"

  /*
   * We have a "type declaration" for our filter criteria.
   *
   * Figuring out how to further massage our SQL.
   */
  split:x:(/../*/filter|/../*/.defaults/*/filter)/$?value
    =:":"
  switch:x:/@split/0?name
    case:inbox
      set:x:/@_filter?value
        src:@"and emails.type='received'"
    case:sent
      set:x:/@_filter?value
        src:@"and emails.type='sent'"
    case:unread
      set:x:/@_filter?value
        src:@"and emails.isread=0 and emails.type='received'"
    case:read
      set:x:/@_filter?value
        src:@"and emails.isread=1 and emails.type='received'"
    case:safe
      set:x:/@_filter?value
        src:@"and emails.encrypted != 0 and emails.fingerprint is not null"
    case:attachment
      set:x:/@_filter?value
        src:@"and exists (select * from attachments where attachments.emailid = emails.id)"
    case:all
      set:x:/@_filter?value
        src:@""
    default
      micro.windows.info:I don't recognize your type declaration
        class:micro-windows-info warning

  /*
   * Checking if we actually had a filter criteria.
   */
  if:x:/@split/*?count
    >:int:1

    /*
     * There was a filter, in addition to a type declaration.
     */
    set:x:(/../*/filter|/../*/.defaults/*/filter)/$?value
      src:x:/@split/0/-?name
  else

    /*
     * There was no filter, only a type declaration.
     */
    set:x:(/../*/filter|/../*/.defaults/*/filter)/$?value
      src:





/*
 * Opening database and selecting top 15 emails, sorted descendingly by date.
 */
p5.mysql.connect:[sephia]

  /*
   * Selecting 15 newest emails.
   *
   * Notice, we do not order by date, since dates might sometimes be local, and/or slightly offsets.
   * Hence, we order our emails by "id" descendingly, which should always bring in the most recent email at the top.
   */
  p5.mysql.select:@"select emails.id, subject, date, encrypted, signature, emails.fingerprint, isread, type, contacts.email, contacts.name from emails inner join contacts on contacts.id = emails.sender 
where emails.username = @username and (subject like @filter or contacts.name like @filter or contacts.email like @filter 
or exists (select * from parts where content like @filter and parts.emailid = emails.id)) {0}
order by id desc limit 15 offset @offset"
    :x:/@_filter?value
    @username:x:/@whoami/*/username?value
    @offset:x:(/../*/offset|/../*/.defaults/*/offset)/$?value.int
    @filter:%{0}%
      :x:(/../*/filter|/../*/.defaults/*/filter)/$?value

  /*
   * Creating rows for our grid databind operation below.
   */
  for-each:x:/@p5.mysql.connect/*/p5.mysql.select/*

    /*
     * Creating CSS class of row according to status of currently iterated email.
     */
    _class
    if:x:/@_dp/#/*/type?value
      =:sent

      /*
       * This email was sent by currently logged in user.
       */
      set:x:/@_class?value
        src:{0} sephia-sent
          :x:/@_class?value

    else-if:x:/@_dp/#/*/isread?value.int
      =:int:0

      /*
       * This email is still unread.
       */
      set:x:/@_class?value
        src:{0} sephia-unread
          :x:/@_class?value

    if:x:/@_dp/#/*/encrypted?value.int
      =:int:1

      /*
       * This email was sent encrypted.
       */
      set:x:/@_class?value
        src:{0} sephia-encrypted
          :x:/@_class?value

    if:x:/@_dp/#/*/fingerprint?value
      and:x:/@_dp/#/*/fingerprint?value
        !=:

      /*
       * This email was sent signed.
       */
      set:x:/@_class?value
        src:{0} sephia-signed
          :x:/@_class?value

    /*
     * Nicely formatting the date, and cleaning up CSS class.
     */
    p5.types.date.format:x:/@_dp/#/*/date?value
      format:"d. MMM yyyy - HH:mm"
    set:x:/@_class?value
      trim:x:/@_class?value

    /*
     * Adding signed icon, if we should.
     */
    if:x:/@_dp/#/*/fingerprint?value
      and:x:/@_dp/#/*/fingerprint?value
        !=:
      add:x:/..for-each/*/add/**/Date/*/widgets/*/div/*/widgets
        src
          literal
            element:span
            class:icon-paw

    /*
     * Checking if email has attachments.
     */
    p5.mysql.scalar:@"select count(*) from attachments where emailid = @id"
      @id:x:/@_dp/#/*/id?value
    if:x:/@p5.mysql.scalar?value.int
      >:int:0
      add:x:/..for-each/*/add/**/Date/*/widgets/*/div/*/widgets
        src
          literal
            element:span
            class:icon-paperclip


    /*
     * Adding encrypted icon, if we should.
     */
    if:x:/@_dp/#/*/encrypted?value.int
      !=:int:0
      add:x:/..for-each/*/add/**/Date/*/widgets/*/div/*/widgets
        src
          literal
            element:span
            class:icon-lock

    /*
     * Forward evaluating arguments, and creating our row.
     */
    eval-x:x:/+/*/*/*|/+/*/*/*/Date/**|/+/*/*/*/.row/*(/*/*/id|/title|/class|/.row-email-id)
    add:x:/../*/micro.widgets.grid.databind
      src
        item
          .row
            title:x:/@_dp/#/*/email?value
            class:x:/@_class?value
            .row-email-id:x:/@_dp/#/*/id?value
            onclick

              /*
               * Executing file responsible for reading a single email.
               */
              load-file:@SEPHIA/inbox/read-email.hl
              eval-x:x:/+/*
              eval:x:/-2/*
                id:x:/@_dp/#/*/id?value

          Name:x:/@_dp/#/*/name?value
          Subject:x:/@_dp/#/*/subject?value
          Date
            widgets
              span
                innerValue:x:/@p5.types.date.format?value
              div
                class:sephia-status
                widgets


/*
 * Actual databind operation for grid.
 */
micro.widgets.grid.databind:sephia-inbox


/*
 * Returning true to signal that we actually had items, and were
 * able to re-databind grid.
 */
return:bool:true
