
/*
 * File responsible for fetching emails.
 *
 * This will spawn of a new thread, which runs in the background "forever", or until an exception
 * occurs, or user closes his browser window. But it will only fork one new thread for each user in the system.
 *
 * This thread will run in the background, and fetch new emails from the user's POP3 server, then sleep
 * for n seconds, before starting fetching emails again.
 *
 * It will iterate like this for 5 times, and then simply "die off" unless some other parts of the
 * program has zero'ed its counter, which is stored in p5.data.
 *
 * Notice, it works in combination with the "create-client-server-poller.hl" file, which will create a timeout JavaScript
 * object, that polls the server every n seconds, which zeroes out the iteration counter, while it checks 
 * for new emails.
 */


/*
 * Forking our retrieve emails thread, making sure we have only one thread for each user.
 * This thread runs constantly in the background, and fetches new emails every n'th second from the users
 * POP3 server.
 *
 * Creating a temporary lock for user, to make sure only one thread trying to spawn a new worker thred exists 
 * at the same time.
 */


/*
 * Used further down.
 */
whoami


/*
 * Making sure there's only one thread at the time that tries to create a user "worker thread".
 *
 * Otherwise in theory we could have multiple GUI threads evaluating this file, which would 
 * create multiple "POP3 worker threads".
 */
lock:sephia.core.thread-signal-object-{0}
  :x:/@whoami/*/username?value


  /*
   * Checking if "thread signal object" exists.
   */
  select-data:x:/*/*/sephia.core.thread-signal-object-{0}
    :x:/@whoami/*/username?value
  if:x:/@select-data/*?value

    /*
     * Thread signal object already exists, returning early.
     */
    return:bool:true


  /*
   * Creating our initial "POP3 worker thread signal object".
   */
  set:x:/+/*?name
    src:sephia.core.thread-signal-object-{0}
      :x:/@whoami/*/username?value
  insert-data
    thread
      running:bool:true
        count:int:0


/*
 * Passing in entire [whoami] to [fork] lambda.
 */
add:x:/../*/fork/*/.whoami
  src:x:/@whoami/*


/*
 * Passing in user's attachment folder to thread.
 */
set:x:/../*/fork/*/_users-home-folder?value
  p5.io.unroll-path:@SEPHIA-USER-ATTACHMENTS/


/*
 * Passing in user settings to [fork].
 */
p5.auth.my-settings.get
add:x:/../*/fork/*/.settings
  src:x:/@p5.auth.my-settings.get/*/sephia/*


/*
 * Creating an new POP3 worker thread.
 */
fork

  /*
   * Passed in above.
   */
  .whoami
  .settings
  _users-home-folder

  /*
   * If an exception occurs, we abort further fetching operations, by gracefully
   * escaping loop, and stopping thread.
   */
  try

    /*
     * "Neveer ending while loop", that will fetch emails from POP3 server "forever", or until an exception occurs.
     * It will basically iterate once, wait for n seconds, and start iterating again.
     * It will not iterate more than 5 times though, unless som client has polled the server for new emails.
     * This avoids having multiple background threads, for users no longer connected to their inbox.
     */
    while:bool:true

      /*
       * Checking if another thread told us to stop.
       * First retrieving "signal object".
       */
      select-data:x:/*/*/sephia.core.thread-signal-object-{0}
        :x:/@.whoami/*/username?value

      /*
       * Then checking if we have exceeded our iteration count, 
       * or some parts of our program has told our thread to restart.
       */
      if:x:/@select-data/*/*/restart?value
        or:x:/@select-data/*/*/running/*/count?value.int
          >=:int:5

        /*
         * Thread should be stopped and restarted for some reasons, or there has not been a client
         * polling the server for information for more than 5 iterations, which means thread is no longer needed.
         *
         * Regardless, we delete signal object, and return, exiting the thread.
         */
        delete-data:x:/*/*/sephia.core.thread-signal-object-{0}
          :x:/@.whoami/*/username?value
        return

      /*
       * Fetching all the latest emails in an inner while loop, that doesn't sleep,
       * to avoid using n seconds wait between fetching each new email batch, for cases
       * where the user has more than 20 new unread emails on his POP3 server.
       */
      while:bool:true

        /*
         * Fetching new emails from POP3 server, making sure we forward evaluate settings.
         */
        eval-x:x:/+/*|/+/*/decrypt/**
        p5.pop3.get
          server:x:/@.settings/*/pop3-server?value
          port:x:/@.settings/*/pop3-port?value
          ssl:x:/@.settings/*/pop3-ssl?value
          username:x:/@.settings/*/pop3-username?value
          password:x:/@.settings/*/pop3-password?value
          attachment-folder:x:/@_users-home-folder?value
          count:20
          decrypt
            fingerprint:x:/@.settings/*/pgp-key?value
              password:x:/@.settings/*/pgp-password?value
          .onfinished

            /*
             * Storing emails in database.
             */
            p5.mysql.connect:[sephia]
              p5.mysql.transaction.begin

                /*
                 * Stuffing emails into database, storing whether or not there were any new emails.
                 */
                for-each:x:/@p5.pop3.get/*/envelope

                  /*
                   * Checking if email has alread been fetched from POP server
                   */
                  p5.mysql.scalar:@"select count(*) from emails where mimeid = @mimeid and type = 'received'"
                    @mimeid:x:/@_dp/#?value
                  if:x:/@p5.mysql.scalar?value
                    >:long:0

                    /*
                     * Email has already been fetched.
                     * No need to continue.
                     */
                    continue

                  /*
                   * Checking if email was signed/encrypted, and if so, 
                   * making sure we pass in email of first signature to "email" table insertion.
                   */
                  _signature
                  _fingerprint
                  _encrypted:int:0
                  _babel-subject
                  if:x:/@_dp/#/*/multipart/*/signature/*?value

                    /*
                     * Email was cryptographically signed.
                     * Storing both email and fingerprint of key used to sign email.
                     */
                    set:x:/@_signature?value
                      src:x:/@_dp/#/*/multipart/*/signature/0?name
                    set:x:/@_fingerprint?value
                      src:x:/@_dp/#/*/multipart/*/signature/0/0?value

                  if:x:/@_dp/#/*/multipart/*/decryption-key

                    /*
                     * Email was encrypted.
                     */
                    set:x:/@_encrypted?value
                      src:int:1

                    /*
                     * Checking if we have a "hidden subject" in email, which should be stored inside of our
                     * multipart as base64 encoded inside the value of a "X-Subject" MIME header, if it exists.
                     *
                     * Notice, if email was encrypted, its original part should exist inside of the outer multipart,
                     * which was created as a consequence of wrapping our entire root part inside of a "multipart/encrypted"
                     * wrapper MIME entity.
                     */
                    if:x:/@_dp/#/*/multipart/*/*/X-Subject?value

                      /*
                       * There is a "hidden subject" in email, making sure we first store the "babel subject", before
                       * we retrieve the real subject.
                       */
                      set:x:/@_babel-subject?value
                        src:x:/@_dp/#/*/Subject?value
                      set:x:/@_dp/#/*/Subject?value
                        p5.string.decode-base64:x:/@_dp/#/*/multipart/*/*/X-Subject?value

                      /*
                       * Removing subject from body of email, which should have been added during creation.
                       */
                      html2lambda:x:/@_dp/#/*/multipart/**/text/=html/*/content?value
                      if:x:/@html2lambda/*

                        /*
                         * Email contained HTML part, removing first "h3" header, which is our real subject,
                         * injected into body of HTML parts of email when email was sent.
                         */
                        set:x:/@html2lambda/**/h3/[0,1]
                        set:x:/@_dp/#/*/multipart/**/text/=html/*/content?value
                          lambda2html:x:/@html2lambda/*

                      /*
                       * Then removing first line of text from text part.
                       */
                      index-of:x:/@_dp/#/*/multipart/**/text/=plain/*/content?value
                        src:"\r\n"
                      +:x:/@index-of/0?value
                        _:4
                      split:x:/@_dp/#/*/multipart/**/text/=plain/*/content?value
                        =:x:/@+?value
                      set:x:/@_dp/#/*/multipart/**/text/=plain/*/content?value
                        src:x:/@split/1?name


                  /*
                   * Making sure we store the "from" database ID.
                   */
                  _from

                  /*
                   * Stuffing email's [From] (sender) into "contacts" table.
                   */
                  p5.mysql.select:@"select name, id from contacts where email = @email and username = @username"
                    @email:x:/@_dp/#/*/From/*?value
                    @username:x:/@.whoami/*/username?value

                  /*
                   * Checking if entry exists.
                   */
                  if:x:/@p5.mysql.select/*?count
                    =:int:0

                    /*
                     * Doesn't exist, inserting new entry.
                     * Passing in [fingerprint] for PGP key that signed the email, if a signature was given.
                     */
                    if:x:/@_signature?value
                      add:x:/./*/set/*
                        src
                          fingerprint:x:/@_signature?value

                    /*
                     * Creating contact by evaluating [sephia._internals.contacts.create], and using
                     * return value is "id" for contact.
                     */
                    eval-x:x:/+/*/*/*
                    set:x:/@_from?value
                      fetch:x:/0/*/id?value
                        sephia._internals.contacts.create
                          name:x:/@_dp/#/*/From/0?name
                          email:x:/@_dp/#/*/From/0?value
                          username:x:/@.whoami/*/username?value

                  else-if:x:/@p5.mysql.select/0/*/name?name
                    !=:x:/@_dp/#/*/From/*?name
                    and:x:/@_dp/#/*/From/*?name
                      !=:

                    /*
                     * Exists, but name has been changed, and name given is not empty ("").
                     */
                    p5.mysql.update:@"update contacts set name = @name where id = @id"
                      @id:x:/@p5.mysql.select/0/*/id?value
                      @name:x:/@_dp/#/*/From/*?name
                    set:x:/@_from?value
                      src:x:/@p5.mysql.select/0/*/id?value

                  else

                    /*
                     * Exists, and there are no changes.
                     */
                    set:x:/@_from?value
                      src:x:/@p5.mysql.select/0/*/id?value

                  /*
                   * Verifying that a subject was given by POP3 server.
                   */
                  if:x:/@_dp/#/*/Subject?value
                    not

                    /*
                     * No subject was given, adding empty string as default value.
                     */
                    set:x:/@_dp/#/*/Subject?value
                      src:

                  /*
                   * Now we can insert email into database.
                   */
                  p5.mysql.insert:@"insert into emails (subject, babelsubject, date, sender, username, isread, mimeid, signature, fingerprint, encrypted, type, inreplyto) values (@subject, @babelsubject, @date, @sender, @username, 0, @mimeid, @signature, @fingerprint, @encrypted, 'received', @inreplyto)"
                    @subject:x:/@_dp/#/*/Subject?value
                    @babelsubject:x:/@_babel-subject?value
                    @date:x:/@_dp/#/*/Date?value
                    @sender:x:/@_from?value.uint
                    @username:x:/@.whoami/*/username?value
                    @mimeid:x:/@_dp/#?value
                    @signature:x:/@_signature?value
                    @fingerprint:x:/@_fingerprint?value
                    @encrypted:x:/@_encrypted?value
                    @inreplyto:x:/@_dp/#/*/In-Reply-To?value

                  /*
                   * Now inserting into "attachments" table.
                   */
                  for-each:x:/@_dp/#/**/filename
                    p5.mysql.insert:@"insert into attachments (filename, prefix, folder, emailid) values (@filename, @prefix, @folder, @emailid)"
                      @filename:x:/@_dp/#?value
                      @prefix:x:/@_dp/#/*/prefix?value
                      @folder:x:/@_dp/#/*/folder?value
                      @emailid:x:/@for-each/@p5.mysql.insert/*/id?value

                  /*
                   * Now inserting all "parts" into "parts" table.
                   */
                  for-each:x:/@_dp/#/**/text/*/content/.
                    p5.mysql.insert:@"insert into parts (type, content, emailid) values (@type, @content, @emailid)"
                      @type:x:/@_dp/#?value
                      @content:x:/@_dp/#/*/content?value
                      @emailid:x:/@for-each/@p5.mysql.insert/*/id?value

                  /*
                   * Stuffing email adresses into "contacts" and "recipients" tables.
                   */
                  for-each:x:/@_dp/#/*(/To|/Cc|/Bcc)/*

                    /*
                     * Used to hold "contact" database ID, for later insertion into "recipients" table.
                     */
                    _contact-id

                    /*
                     * Checking if contact exists in database "contact" table.
                     */
                    p5.mysql.select:@"select name, id from contacts where email = @email and username = @username"
                      @email:x:/@_dp/#?value
                      @username:x:/@.whoami/*/username?value

                    /*
                     * Checking if entry exists.
                     */
                    if:x:/@p5.mysql.select/*?count
                      =:int:0

                      /*
                       * Entry does not exist.
                       *
                       * Invoking [sephia._internals.contacts.create] to create our contact, which will
                       * try to look for a PGP key, etc for recipient.
                       */
                      set:x:/@_contact-id?value
                        fetch:x:/0/*/id?value
                          sephia._internals.contacts.create
                            name:x:/@_dp/#?name
                            email:x:/@_dp/#?value
                            username:x:/@.whoami/*/username?value

                    else-if:x:/@p5.mysql.select/0/*/name?value
                      !=:x:/@_dp/#?name
                      and:x:/@_dp/#?name
                        !=:

                      /*
                       * Exists, but sender has updated his name.
                       */
                      p5.mysql.update:@"update contacts set name = @name where id = @id"
                        @name:x:/@_dp/#?name
                        @id:x:/@p5.mysql.select/0/*/id?value
                      set:x:/@_contact-id?value
                        src:x:/@p5.mysql.select/0/*/id?value

                    else

                      /*
                       * Exists, and there are no changes.
                       */
                      set:x:/@_contact-id?value
                        src:x:/@p5.mysql.select/0/*/id?value

                    /*
                     * Inserting into "recipients" table.
                     */
                    p5.mysql.insert:@"insert into recipients (contactid, type, emailid) values (@contactid, @type, @id)"
                      @contactid:x:/@_contact-id?value
                      @type:x:/@_dp/#/.?name
                      @id:x:/@for-each/@p5.mysql.insert/*/id?value

                /*
                 * Commit database transaction.
                 *
                 * Notice, if we come this far, without exceptions, and the commit below succeeds, the [p5.pop3.get] event
                 * will send the QUIT signal to the POP3 server, committing the transaction, registering emails as deleted on POP3 server.
                 */
                p5.mysql.transaction.commit

            /*
             * Checking if there was less than 20 messages fetched, at which point we break the inner [while] loop.
             * If so, the thread will sleep for n seconds, before attempting to fetch new emails from POP3 server again.
             */
            if:x:/@p5.pop3.get/*/envelope?count
              <:int:20
              break

      /*
       * Sleeping current thread for n seconds, before we start continute our outer [while], 
       * which will start fetching again.
       */
      sleep:10000

      /*
       * Making sure we have synchronised access to our "thread signal object".
       */
      lock:sephia.core.thread-signal-object-{0}
        :x:/@.whoami/*/username?value

        /*
         * Updating iteration count, if it exists.
         */
        select-data:x:/*/*/sephia.core.thread-signal-object-{0}/*/running/*/count?value
          :x:/@.whoami/*/username?value
        if:x:/-/*?value

          /*
           * We have an iteration count, which means we must increment it by one.
           */
          +:x:/@select-data/*?value.int
            _:int:1
          update-data:x:/*/*/sephia.core.thread-signal-object-{0}/*/running/*/count?value
            :x:/@.whoami/*/username?value
            src:x:/@+?value

  catch

    /*
     * Making sure we lock the user until error mesage has been inserted into p5.data.
     */
    lock:sephia.core.thread-signal-object-{0}
      :x:/@whoami/*/username?value

      /*
       * Deleting the fact that current user has a fetcher thread, 
       * which he doesn't anymore, as we leave this catch.
       */
      delete-data:x:/*/*/sephia.core.thread-signal-object-{0}
        :x:/@.whoami/*/username?value

      /*
       * Storing error message in database.
       */
      set:x:/+2/*?name
        src:sephia.core.thread-signal-object-{0}
          :x:/@.whoami/*/username?value
      eval-x:x:/+/*/*/*
      insert-data
        thread
          error
            message:x:/@message?value
            type:x:/@type?value
            stack-trace:x:/@stack-trace?value
