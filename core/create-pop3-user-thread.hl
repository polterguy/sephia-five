
/*
 * File responsible for fetching emails.
 *
 * This will spawn of a new thread, which runs in the background "forever", or until an exception
 * occurs, or user logs out of Sephia Five. It will only spawn one such "worker thread" for each user in the system.
 *
 * This thread will run in the background, and fetch new emails from the user's POP3 server, then sleep
 * for n seconds, before checking for emails again.
 *
 * It will iterate like this n times, and then simply "stop gracefully", unless some other parts of the
 * program has zero'ed its counter, which is stored in p5.data.
 *
 * Notice, it works in combination with the "create-client-server-poller.hl" file, which will create a timeout JavaScript
 * object, that polls the server every n seconds, which zeroes out the iteration counter, while it checks 
 * for new emails, every time it has "polled" the server to check for new emails.
 *
 * These parts of the system is possibly among the more complex parts, but unfortunately necessary, since it implies
 * multi-threading, synchronizing access to signal objects, etc.
 *
 * If another thread already exists, and we never created a new thread, this file will return "false".
 * Otherwise it will return boolean "true".
 */





/*
 * Used further down.
 */
whoami





/*
 * Making sure we have easy access to "thread signal object name".
 */
eval-x:x:/../**/_thread-signal
_thread-signal:sephia.core.thread-signal-{0}
  :x:/@whoami/*/username?value





/*
 * Making sure there's only one thread at the time that tries to create a "POP3 worker thread",
 * and if thread already exists, we return early.
 *
 * Otherwise, at least in theory, we could have multiple GUI threads evaluating this file, which would 
 * create multiple "POP3 worker threads" for each user.
 */
write-lock:x:/@_thread-signal?value

  /*
   * Checking if "thread signal object" exists.
   */
  select-data:x:/*/*/{0}
    :x:/@_thread-signal?value
  if:x:/@select-data/*?value

    /*
     * Thread signal object already exists, returning early.
     *
     * This either means that an error has occurred, or thread is already running perfectly fine,
     * and does not need to be created.
     */
    return:bool:false

  /*
   * Creating our initial "POP3 worker thread signal object".
   */
  set:x:/+/*?name
    src:x:/@_thread-signal?value
  insert-data
    thread
      running:bool:true
        count:int:0





/*
 * Passing in entire [whoami] to [fork] lambda.
 */
add:x:/../*/fork/*/.whoami
  src:x:/@whoami/*





/*
 * Passing in user's attachment folder to thread.
 */
set:x:/../*/fork/*/_users-home-folder?value
  p5.io.unroll-path:@SEPHIA-USER-ATTACHMENTS/





/*
 * Passing in user settings to [fork].
 */
p5.auth.my-settings.get
add:x:/../*/fork/*/.settings
  src:x:/@p5.auth.my-settings.get/*/sephia/*





/*
 * Loading configuration for POP3 worker thread, and applying configuration
 * for our worker thread.
 */
load-file:@SEPHIA/config/pop3-thread.hl
set:x:/../*/fork/**/sleep?value
  src:x:/@load-file/*/*/sleep-between-fetch?value
set:x:/../*/fork/**/_emails-2-fetch?value
  src:x:/@load-file/*/*/emails-2-fetch-in-batch?value
set:x:/../*/fork/**/_delete-emails?value
  src:x:/@load-file/*/*/delete-emails?value





/*
 * Creating a new POP3 worker thread.
 *
 * This is where the actual work is done, and we're fetching new emails from the user's POP3 server.
 * It goes in a loop, that basically will run "forever" as long as user is logged into system, and
 * no exceptions occurs as we fetch emails from the user's POP3 server.
 *
 * It creates signals for other threads using p5.data, and a data item called [sephia.core.thread-signal-XXX]
 * where "XXX" is the user's username.
 */
fork

  /*
   * Passed in, or forward evaluated above.
   */
  .whoami
  .settings
  _users-home-folder
  _emails-2-fetch
  _delete-emails
  _thread-signal:sephia.core.thread-signal-{0}
    :x:/@whoami/*/username?value

  /*
   * If an exception occurs, we abort further POP3 fetching operations, by gracefully exiting thread.
   *
   * At which point our "thread signal object" will contain the exception object that was raised.
   *
   * Notice, we never allow exceptions to leave thread.
   */
  try

    /*
     * "Neveer ending while loop", that will fetch emails from POP3 server "forever", or until an exception occurs.
     *
     * It will basically evaluate once, wait for n seconds, and then evaluate again.
     *
     * It will not evaluate more than 5 times though, unless some client has polled the server for new emails.
     * This avoids having multiple background threads, for users no longer connected to their inbox, and hence
     * creates no overhead for user's not actively using Sephia Five.
     */
    while:bool:true

      /*
       * Checking if we should continue this thread, or gracefull return, preventing further
       * evaluation of thread.
       *
       * Notice, this file will return boolean "false" if we should stop thread, and "true"
       * if we should continue our loop.
       */
      eval-x:x:/+/*
      micro.evaluate.file:@SEPHIA/core/increment-pop3-thread-count.hl
        thread-signal:x:/@_thread-signal?value
      if:x:/-?value
        not

        /*
         * Gracefully exiting thread.
         */
        break

      /*
       * Fetching the n latest emails in an inner while loop, that doesn't sleep,
       * to avoid using n seconds wait between fetching each new email batch, for cases
       * where the user has more than n new unread emails in his POP3 server queue.
       */
      while:bool:true

        /*
         * Fetching new emails from POP3 server, making sure we forward evaluate settings.
         */
        eval-x:x:/+/*|/+/*/decrypt/**
        p5.pop3.get
          server:x:/@.settings/*/pop3-server?value
          port:x:/@.settings/*/pop3-port?value
          ssl:x:/@.settings/*/pop3-ssl?value
          username:x:/@.settings/*/pop3-username?value
          password:x:/@.settings/*/pop3-password?value
          attachment-folder:x:/@_users-home-folder?value
          count:x:/@_emails-2-fetch?value
          delete:x:/@_delete-emails?value
          decrypt
            fingerprint:x:/@.settings/*/pgp-key?value
              password:x:/@.settings/*/pgp-password?value
          .onfinished

            /*
             * Storing emails in database, making sure we use a transaction,
             * such that no partial objects are stored.
             */
            p5.mysql.connect:[sephia]
              p5.mysql.transaction.begin

                /*
                 * Iterating through each email and invoking file responsible for storing email into database.
                 */
                for-each:x:/@p5.pop3.get/*/envelope

                  /*
                   * Passing in [envelope] and [whoami] object, which is needed to know which user to save email on behalf of.
                   */
                  add:x:/..for-each/*/micro.evaluate.file
                    src:x:/@_dp/#
                  add:x:/..for-each/*/micro.evaluate.file
                    src:x:/@.whoami/*/username
                  micro.evaluate.file:@SEPHIA/core/save-pop3-email-2-database.hl


                /*
                 * Commit database transaction.
                 *
                 * Notice, if we come this far, without exceptions, and the commit below succeeds, the [p5.pop3.get] event
                 * will send the QUIT signal to the POP3 server, committing the transaction, registering emails as deleted 
                 * on our POP3 server.
                 */
                p5.mysql.transaction.commit

            /*
             * Checking if there was less than 20 messages fetched, at which point we break the inner [while] loop.
             *
             * If there were fewer than 20 email, our thread will sleep for n seconds, before attempting to fetch new 
             * emails from our POP3 server again.
             */
            if:x:/@p5.pop3.get/*/envelope?count
              <:x:/@_emails-2-fetch?value
              break

      /*
       * Sleeping current thread for n seconds, before we continue our outer [while], 
       * which will start fetching again.
       *
       * Notice, this value is pre-applied before entering fork, and taken from Sephia's 
       * configuration settings.
       */
      sleep

  catch

    /*
     * Making sure we have synchronized access to our "thread signal object".
     */
    write-lock:x:/@_thread-signal?value

      /*
       * Deleting the fact that current user has a fetcher thread, 
       * which he doesn't anymore, as we leave this catch, and making sure
       * we insert our exception information into our "thread signal object".
       */
      delete-data:x:/*/*/{0}
        :x:/@_thread-signal?value

      /*
       * Storing error message in database.
       */
      set:x:/+2/*?name
        src:x:/@_thread-signal?value
      eval-x:x:/+/*/*/*
      insert-data
        thread
          error
            message:x:/@message?value
            type:x:/@type?value
            stack-trace:x:/@stack-trace?value





/*
 * Returning success to caller, which indicates that a new thread was spawned.
 */
return:bool:true
